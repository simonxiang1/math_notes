\section{February 2, 2022: Pset 2} 
\begin{prob}
    An addition chain for an integer $n$ is an increasing sequence of integers that starts with 1 and ends with $n$, such that each entry after the first is the sum of two earlier entries. More formally, the integer sequences $x_0 < x_1 < x_2 < \cdots <x_{\ell}$ is an addition chain for $n$ iff 
    \begin{itemize}
    \setlength\itemsep{-.2em}
        \item $x_0=1$ 
        \item $x_{\ell}=n$ 
        \item For every index $k>0$, there are indices $i \leq j < k$ such that $x_k=x_i +x_j $.
    \end{itemize}
    The length of an addition chain is the number of elements minus 1; we don't bother to count the first entry. 
    \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{-.2em}
        \item   Describe a recursive backtracking algorithm to compute a minimum length addition chain for a given positive integer $n$.
    \end{enumerate}
\end{prob}
\begin{solution}
    Our recursive subproblem is to define a function \texttt{addchain(i)} that takes an integer and returns the length of a minimum length addition chain. Define \texttt{min} to be some large number, which we use as our current minimum, as well as a vector \texttt{chain} to store the current chain, and a vector \texttt{minchain} to store our minimal length chain (the answer). First, if the length of \texttt{chain} is greater than \texttt{min}, return.  If $i=n$, check if the length of \texttt{chain} is less than \texttt{min}, if so, set \texttt{minchain} to be \texttt{chain}-- this finishes our termination conditions for recursion. Using bottom-up recursion, loop through the vector decreasingly (say using $j$); if $i+$\texttt{chain}$(j)\leq n$, append $i+$\texttt{chain}$(j)$ to \texttt{chain} (constructing the addition chain), and call \texttt{addchain}$(i+$\texttt{chain}$(j))$ (recursive call). Finally, return the length of \texttt{minchain}.
    Pseudocode:
    \begin{verbatim}
    min = very big number
    vector chain = 1
    vector minchain
    n = some int
     
    def addchain(i){
        if (length(chain)>=min) return
        if (i = n){
            min = length(chain), minchain = chain
        }       

        for (j = length(chain), j>=0, j--){
            if (i + chain(j) <= n){
                append(i+chain(j)) to chain
                addchain(i+chain(j))
            }
        } 
    } 

    addchain(1)
    return length(minchain)
    \end{verbatim}
    This gives a minimal length addition chain because it generates all possible chains, and the second if statement checks to see whether a chain is minimal or not.
\end{solution}

\begin{prob}
    
\end{prob}
\begin{solution}
    Sorry I couldn't finish most of problem 2. 
    \begin{enumerate}[label=(\alph*)]
    \setlength\itemsep{-.2em}
        \item Values:
            \begin{verbatim}
               Without memoization:
158 ms ± 3.58 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
With memoization:
6.59 µs ± 52.6 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
With memoization as a decorator:
109 ns ± 5.92 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)
            \end{verbatim}The relative times seem similar to what I'd expected, given the slow recursive \texttt{fib} is exponential, and \text{fib2} is linear. The issue is that \texttt{fib2a} runs super fast, appearing to be constant time when it should be linear.\qedhere
    \end{enumerate}
\end{solution}

