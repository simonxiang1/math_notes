\section{February 9, 2022: Pset 3} 
\begin{prob}
    As written.
\end{prob}
\begin{solution}
    Following the guidelines in the problem, we provide the following information:
    \begin{itemize}
    \setlength\itemsep{-.2em}
\item \emph{Description of subproblems}: Let $M[m,n]$ denote the maximum profit from subdividing an $m \times n$ marble slab. The subproblem is calculating the optimal price following a horizontal or vertical subdivision of a slab. 
\item \emph{A mathematical description of the recurrence involved}: Base case: $m=0$ or $n=0$ (which implies $M[m,n]=0$). Recurrence: Say we have a horizontal cut at $1 \leq i \leq m$, and a vertical cut at $1 \leq j \leq n$. Then $M[m,n] $ is the maximum of both horizontal halves (recursive), both vertical halves (recursive), and the entire thing ($P[m,n]$). Mathematically, we would write \[
        M[m,n]=\max \left\{ P[m,n],(M[i,n]+M[n-i,m]),(M[n,j]+M[n,m-j]) \right\}.
\] 
        \item \emph{How to compute the final answer using this recurrence}: The final answer is $M[m,n]$.
        \item \emph{A description of how to solve all the subproblems}: We would solve the subproblems by looping through $i$ and $j$, checking to see if their sums exceed $P[m,n]$, and if they do, set the larger one as the new max and recurse.
        \item \emph{Runtime analysis}: Write this recurrence as $T(n)=T(n /2) + T(n /2) +O(1)$ (up to constants), then by the master theorem (with $a=2,b=2,f(n)=1$), apply case one since $f(n)=O(n^{\log_ba-\varepsilon })$. Here $\log_ba=\log_22=1, \varepsilon =1>0$, then $f(n)=O(n^{1-1})=O(1)$. Therefore by the master theorem $T(n)=O(n^{\log_ba})=O(n)$.
    \end{itemize}
    This concludes the problem.
\end{solution}

\begin{prob}
    As in the Jupyter notebook.
\end{prob}
\begin{solution}
    Jupyter notebook attached to the Canvas submission.
   \begin{enumerate}[label=(\alph*)]
   \setlength\itemsep{-.2em}
       \item Here, the $f(t)$ represents the length of the optimal bill-splitting of a certain amount given arbitary denominations. For example, $f(99)$ working with the standard currency ($50,25,10,5,1$) would be 8, due to the splitting $(50,25,10,10,1,1,1,1)$ having size 8.
       \item This algorithm runs in exponential $O(2^n )$ time, because we solve subproblems over and over again (generating the entire tree).
       \item Let $d$ denote the number of denominations, then the runtime of \texttt{change\_size\_memoized} is 
           \[
           O(d\cdot \texttt{amount})= O(n^2)
       \] because for each bill ($d$), we make \texttt{amount} subtractions, and everything else runs in constant time.
   \item This has complexity $O(2^d\cdot \texttt{amount})=O(2^n )$. As opposed to the $O(d \cdot \texttt{amount}) $ case, we make \texttt{amount} subtractions for each possible subset of denominations, rather than just for each denomination $d$.
   \item This also has polynomial linear asymptotic complexity $O(d\cdot \texttt{amount})=O(n^2)$, since we only go through one for loop from 1 to \texttt{amount}$+1$ and another throughout the bills in the denomination $(d) $.
    \item Empirically, the runtime looks very similar to \texttt{change\_size\_memoized}, except this algorithm runs slightly faster. They both seem to grow at the same rate, since they both run in polynomial time.
    \item Once again this has complexity $O(d \cdot \texttt{amount})=O(n^2) $ represented by a nested for loop of length $d$ and length \texttt{amount}.
   \end{enumerate}
\end{solution}
