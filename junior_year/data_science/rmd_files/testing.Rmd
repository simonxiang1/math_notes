```{r}
1 + 1 ##this is how you comment
2 - 1
3 * 3
3 / 3
sin(2 * pi) ##functions eg sin
```

## Loading packages

```{r, message=FALSE, warning=FALSE}
library("tidyverse") ##loading packages
library("dslabs")
```

## Defining variables

```{r}
a <- 5 #assign with arrows because sometimes equals doesn't meant assignment
b <- 8
c <- 3

x_1 <- (-b + sqrt(b^2 - 4 * a * c )) / 2 / a
x_2 <- (-b - sqrt(b^2 - 4 * a * c )) / 2 / a

print(x_2)
```

## LaTeX in R

$$ 
    a  x^2 + bx + c = 0
$$

## Functions in `R`

```{r}
?sin ##opens up a help page
help("sin") ##same idea
sin(2 * pi)
log(10) ##natural log
log(x = 10, base = 2) ##why we use arrows for assignment
```

## Some built in datasets

```{r}
data("iris") ##loading famous data set: table w/columns
iris ##prints the data
?iris ##maybe a description of what's going on
```

We will mainly be working with data sets throughout this course. In the `dslabs` data set, there is data on murders.

```{r}
data("murders")
murders
```

## Data frames
```{r}
class(iris)
```
## Vectors

```{r}
# sepal_length ## example of a vector in iris
x <- c(1, 2, 3) ## makes a vector
y <- c(TRUE, FALSE, TRUE, FALSE) ## vector of booleans
z <- c("Alice", "Bob", "Calvin") ## vector of strings/chars
print(x)
class(x)
w <- c(x, y) ## transforms y into same type as x, turns bool into int
l <- c(x, z) ## turns int into char
n <- c(y, z) ## turns bool into char
print(w)
print(l)
print(n)
```
How do we access elements of vectors?
```{r}
x[2] ## access using single brackets
x[2] <- 7 ## let's change the second element
x[2]
x[c(1:3)] ## you can feed vectors a vector to access a subset
```

## Lists: vectors of different types
```{r}
my_list <- list(first = x, second = y) #names are arbitrary and don't matter
print(my_list)
print(my_list$second) #accessing elements by variable names
my_list[["second"]]
names(my_list) #retrieve names of lists
names(iris) 
```
Data frames are just fancy lists. It's also possible to access things using double brackets.


## Sequences
Say we want to grab the first 10 components of `iris$Species`. To do this we use a sequence. 
```{r}
print(1:10) ## numbering starts at 1
iris$Sepal.Length[1:10] ## use a colon
```
We can also make sequences with seq.
```{r}
seq(2, 8, by = 2) ## more exotic sequences
iris$Sepal.Length[seq(2, 8, by = 2)] 
```

## Vector arithmetic
Sometimes when coding we want to do basic arithmetic operations on vectors of numbers. The `+, -, *, /` operations all work elementwise.
```{r}
ratio_of_sepal_length_to_sepal_width <- iris$Sepal.Length / iris$Sepal.Width ## does division elementwise
x <- c(1, 2, 3)
y <- c(4, 5, 6)

x + y 
x / y

x <- c(1, 2) 
y <- c(3, 4, 5, 6) ## breaking r- copies 1 and 2 again
x + y ## will give an error if shorter is not multiple than longer
round(x = ratio_of_sepal_length_to_sepal_width, 2)
```
Try not to break things.

## Control flow: or, programming in R
How to program in `R`. Nothing should be new here.

### Conditional expressions
```{r}
having_fun <- TRUE
if(having_fun) {
    print("I'm having fun!")
}
if(!having_fun) {
    print("I'm not having fun!")
}
```
Note that `else` statements have to be on the same line as things being closed.
```{r}
having_fun <- TRUE
if(having_fun) {
    print("I'm having fun!")
} else {
    print("I'm not having fun!")
}
```
We can also test numeric values in a conditional statement.
```{r}
favorite_number <- 7
if(favorite_number > 10) {
    print("Bigger than 10")
} else {
    print("Not bigger than 10")
}

favorite_number > 10
favorite_number < 10
favorite_number == 10
favorite_number <= 10
favorite_number != 10
```

### Writing for loops
```{r}
for(i in 1:10) {
    print(i)
}
for(i in c("dog", "cat", "shark")) {
    print(i)
}

tot_sum <- sum(1:10) ## easy way
print(tot_sum)

tot_sum <- 0 ## hard way
for(i in 1:10) {
    tot_sum <- tot_sum + i
}
print(tot_sum)
```
Goal: divide the states into high-crime states and low-crime states. Let's define a high-crime state as a state with at least 35 homicides per million people.

```{r}
murders_per_million <- 1000000 * murders$total / murders$population
cutoff <- 35
num_states <- length(murders_per_million)

high_murders <- logical(num_states) #initializes everything to false
## print(high_murders)

for(i in 1:num_states) {
    if(murders_per_million[i] > cutoff) {
        high_murders[i] <- TRUE
    } else {
        high_murders[i] <- FALSE #this line is completely redundant
    }
}
## print(high_murders)
murders$high_murder <- high_murders ## makes a new col
print(murders)

print(murders$state[murders$high_murder]) #indexing with a bool
```
Here we printed out all the high murder states. Let's let `R` write the loop for us.

```{r}
high_murders_2 <- ifelse(
    test = murders_per_million > cutoff,
    yes = TRUE, no = FALSE
)
high_murders_2
```
This gives the same result as `high_murders`.

## Writing our own functions
`R` has lots of built in functions that we've seen: `sum, mean, length, sqrt` etc. What if we want to define _our own_ function? To do this, we use the `function` keyword. For example:

```{r}
## function with no arguments
my_function <- function() {
    return("I'm a function")
}

## calling function
my_function()
```
Let's define another function that uses arguments.


```{r}
add_x_to_y <- function(x, y = 1) { #default argument for y is 1
    return(x + y)
}

add_x_to_y(5, 3)
add_x_to_y(5)
add_x_to_y(y = 10, x = 3) # can flip the order. doesn't really matter here since this function is symmetric

is_even <- function(x) {
    remainder <- x %% 2 ## local variables

    if(remainder == 0) {
        return(TRUE)
    }
    return(FALSE)
}
is_even(4)
is_even(3)
#print(remainder) #local variables don't stick around

debug(is_even) ##prints stuff line by line
```

## Vectorization
Many functions we want to use accept vectors as input. 
```{r}
x <- 1:10
sum_of_first_n_numbers <- function(n) {
    temp <- 0
    for(i in 1:n){
        temp <- temp + i
    }
    return(temp)
}
for(i in x) {
    print(sqrt(i))
}

sqrt(x)
```

It's best practice to use vectorized objects rather than looping if possible. One reason is performance, things will be faster. Another reason is that `R` by design stylistically prefers to use vectors, so keep loops to a minimum.

For example, `sum_of_first_n_numbers` was not written to accept vectors as input, and we vectorize it using functions from the `apply` family. The following two code blocks do the same thing.

```{r}
sum_of_first_n_numbers <- function(n) {
    temp <- 0
    for(i in 1:n){
        temp <- temp + i
    }
    return(temp)
}

## Let's compute sum_of_first_n_numbers() for n = 1, 2, ..., 100

my_sums <- numeric(100) #initializes it to numeric vect of length 100
print(my_sums)
for(i in 1:100) {
    my_sums[i] <- sum_of_first_n_numbers(i)
}

my_sums <- sapply(1:100, sum_of_first_n_numbers) #does the same thing in one line of code. 
print(my_sums)
```
The `s` in `sapply` stands for simplify, will return things in simple form. `lapply` returns a list, and `apply` is good for matrix things.
